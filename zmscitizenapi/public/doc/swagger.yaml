swagger: "2.0"
info:
  title: ZMS (human waiting queue management) API
  x-logo:
    url: "./logo.png"
  description: |
      The ZMS system is intended to manage human waiting queues. It has the following features:

       * make appointments via a calender and initiate a process to manage an appointment
       * import requests (services) and providers (locations) from external sources
       * manage scopes for appointments, including a four level hierarchy of owner->organisation->department->scope
       * manage opening hours including closed days
       * login-system with different access levels
       * pickup for documents
       * ticketprinter support for customers without appointments (authenticated, lockable, timeable)
       * calldisplay support
       * collecting statistics like waiting time or served clients per day
       * emergency call for employees

       This documentation covers the API-level access to these features.

       ## Common parameters for requests

       ### Header X-JsonCompressLevel

       Setting the header "X-JsonCompressLevel" with a value of 1 or higher enables a json schema based compression. On a value of 1 and higher, default value for properties are omitted. To have a combine the default values in the entity schema with the response. With a value of 2 and higher (not implemented yet), repeating values are referenced inline with a "$ref" property. A JSON-Schema dereferencing is required.

       This header is useful on results with a lot of items.

       ### Parameter resolveReferences

       Most calls support the parameter "resolveReferences". Usually by fetching an entity, it includes an amount of sub entities. For example, a department has a list of scopes. Fetching a department usually does not include the scopes. If you need the scopes of the department, use the parameter "resolveReferences" with a value of 1. This resolves one level of sub entities. If you need for example the availabilities (opening hours) of the scopes, use a value of 2 to fetch two sublevels of entities. Beware, that a high value results in a lot of data which might be redundant.

       Why using a parameter like this and not different api calls? The overhead for an api call is usually on around 20ms. Fetching a list for different entities can easily result in 20 additional requests to fetch the required data. So using this parameter might result having a 10 times higher performance compared to mulitple calls.

       ### Experimental GraphQL parameter

       There is an experimental "gql" parameter to reduce the download size of fetched data. Sometimes only a part of the data is required for the desired operation. This parameter supports a simplified GraphQL query. It is experimental in a sense, that the amount of the supported GraphQL features might change.

       Currently only the selection of desired fields are supported. To get a scope with only the ID and the name, a query like this accomplishes this.

       `/api/2/scope/141/?gql={id+contact{name}}`

       As difference to the GraphQL implementation, a whole sub section might be retrieved by not adding details. But beware of using this, for a stricter GraphQL implementation in the future might break this behavior. To get all contents of `scope.contact` a query like this currently solves this.

       `/api/2/scope/141/?gql={id+contact}`

       The API is currently not GraphQL compatible. A request does not get faster on the server for requesting not every property. But there might be a performance increase on the client side for there is less data to download and decode.
       
  termsOfService: 'http://service.berlin.de/terminvereinbarung/'
  contact:
    name: Mathias Fischer
    email: mathias.fischer@berlinonline.de
    url: 'http://www.berlinonline.net/unternehmen/team/'
  license:
    name: Commercial
    url: 'http://www.berlinonline.net'
  version: '2.25.00-muc11-196-g298ff3727'
basePath: /terminvereinbarung/api/2
schemes:
  - https
consumes:
  - application/json
produces:
  - application/json
securityDefinitions:
  httpauth:
    type: basic
    description: |
        The API uses two variants of authentication. An application can use basic authentication via HTTP for identification. As an alternative, there is a header with the name "X-Authkey". This key can be optained by accessing "/workstation/login/".

        According to the application settings, there might be different rights to use API methods. Further rights depend on the settings for the authorized useraccount.
security:
    - httpauth: []
tags:
  - name: apikey
    description: |
      Über einen "apikey" erhält man Zugriff zu der Terminbuchung. Die Eigenschaft "key" wird für die meisten HTTP-Requests als Header `X-Auth-Key` benötigt.

      Eine Verifikation für einen apikey ist notwendig. Dies erfolgt in der Regel über ein Captcha. Über ein "clientkey" kann man aber auch erweiterte Berechtigungen erhalten, wie zum Beispiel Zugriff auf begrenzte Terminkontingente oder einen Verzicht auf das Captcha. Der "clientkey" wird vom Betreiber des Systems mitgeteilt. Ohne einen solchen "clientkey" werden Standard-Einstellungen verwendet.
      
      Weiterhin gehört zu einem apikey ein Quota für unterschiedliche Requests. Um Missbrauch der Schnittstelle zu vermeiden werden in unterschiedlichen Zeiteinheiten nur eine begrenzte Zahl von Requests zugelassen. Eine Information wieviele Requests noch frei sind, erhält man über den apikey.
  - name: calendar
    description: |
      Ein "calendar" repräsentiert eine Kalender-Ansicht. Diese beinhaltet zum einen die Details der Abfrage, wie für welchen Zeitraum der Kalender gilt und welche Leistungen and welchen Standorten buchbar sind. Als Antwort auf eine Anfrage enthält der Kalender Einträge zu Tagen, an denen Termine buchbar sind.

      Wichtig: Der "calendar" repräsentiert keinen Kalender eines Standortes oder ähnliches. Es handelt sich um ein temporäres Suchobjekt mit Suchergebnissen.
  - name: process
    description: |
      Unter "process" wird ein Vorgang im System verstanden. Ein solcher Vorgang enthält in der Regel einen Termin sowie Kontaktdaten zum Kunden und Details zum Standort des Termins.

      Ein "process" kann auch einen freien Termin repräsentieren. Dies lässt sich über die Eigenschaft `status` erkennen. Ein Status "free" bedeutet, dass es sich um einen freien Termin handelt, ein "reserved" kennzeichnet eine flüchtige Reservierung und ein Vorgang im Status "confirmed" entspricht einem gültigen Termin.
  - name: provider
    description: |
      Ein "provider" entspricht einem physischen Standort mit Ortsdaten wie Straße und Hausnummer und häufig Angaben, wo im entsprechenden Gebäude dieser Dienstleister zu finden ist. Der "provider" legt fest, welche Leistungen ("request") an einem "scope" verfügbar sind. Ein "provider" kann mehrere zugehörige "scope"-Objekte haben.
  - name: scope
    description: |
      Neben dem "provider" gibt es einen "scope". Dieser "scope" umfasst vor allem einem Terminkalender und daneben einen Warteraum (oder auch Aufrufanlage, "calldisplay") und Arbeitsplätze ("workstation"). Wenn mehrere "scope"-Objekte sich einen Warteraum ("calldisplay") und Arbeitsplätze ("workstation") teilen, können diese von einem "cluster" zusammengefasst werden. Dabei müssen die "scope" im Falle eines "cluster" nicht zum selben "provider" gehören.
paths: {}
definitions:
  apikey:
    $ref: "schema/apikey.json"
  apiclient:
    $ref: "schema/apiclient.json"
  appointment:
    $ref: "schema/appointment.json"
  availability:
    $ref: "schema/availability.json"
  calendar:
    $ref: "schema/calendar.json"
  calldisplay:
    $ref: "schema/calldisplay.json"
  client:
    $ref: "schema/client.json"
  cluster:
    $ref: "schema/cluster.json"
  config:
    $ref: "schema/config.json"
  contact:
    $ref: "schema/contact.json"
  day:
    $ref: "schema/day.json"
  department:
    $ref: "schema/department.json"
  dayoff:
    $ref: "schema/dayoff.json"
  exchange:
    $ref: "schema/exchange.json"
  link:
    $ref: "schema/link.json"
  log:
    $ref: "schema/log.json"
  mail:
    $ref: "schema/mail.json"
  mimepart:
    $ref: "schema/mimepart.json"
  metaresult:
    $ref: "schema/metaresult.json"
  notification:
    $ref: "schema/notification.json"
  organisation:
    $ref: "schema/organisation.json"
  owner:
    $ref: "schema/owner.json"
  process:
    $ref: "schema/process.json"
  provider:
    $ref: "schema/provider.json"
  queue:
    $ref: "schema/queue.json"
  request:
    $ref: "schema/request.json"
  requestrelation:
    $ref: "schema/requestrelation.json"
  scope:
    $ref: "schema/scope.json"
  session:
    $ref: "schema/session.json"
  slot:
    $ref: "schema/slot.json"
  source:
    $ref: "schema/source.json"
  status:
    $ref: "schema/status.json"
  ticketprinter:
    $ref: "schema/ticketprinter.json"
  useraccount:
    $ref: "schema/useraccount.json"
  workstation:
    $ref: "schema/workstation.json"